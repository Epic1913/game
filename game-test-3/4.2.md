## 4.2

开始学习下一个项目



又接触了一个游戏编程核心思想：**主循环内应尽量避免阻塞式的行为或者过于繁重且耗时过长的任务** 

所以对于连贯的图片应该使用动画帧索引，而不是sleep的方式来实现动画。



了解到了游戏循环的几个阶段：初始化、更新、渲染



**接下来是一些今天很有收获的点**

------



### 绘制的顺序

1. `cleardevice()`：清除屏幕，为新的绘图操作做好准备。
2. 绘制操作：进行所有的绘制操作，这些操作被保存在缓冲区中，而不是直接显示在屏幕上。
3. `FlushBatchDraw()`：将缓冲区中的所有绘制操作渲染到屏幕上。

按照这个顺序，你可以确保用户看到的是完整的、更新后的帧，而不是在绘制过程中的部分更新状态。

------

### 加载图像

对于有规律的连贯图像可以在循环中用std::wstring来拼凑出图片路径

```
std::wstring path = L"img/player_left_" + std::to_wstring(i) + L".png";
loadimage(&img_player_left[i], path.c_str());
```

#### 图片数组定义在主循环之外

##### 性能优化

- **资源加载与释放**：图片加载到内存是一个耗时的过程，包括从磁盘读取数据和在内存中为图像数据分配空间。如果每次函数调用时都加载图片，将导致不必要的性能开销。此外，频繁的加载和卸载图片也会增加对垃圾收集器的压力（在使用自动内存管理的编程语言中），可能导致游戏出现延迟或卡顿。
- **减少I/O操作**：频繁地从磁盘读取图片数据不仅减慢了游戏的响应速度，还会增加硬件的磨损。

##### 资源管理

- **内存管理**：将图片数组定义在函数外部可以更好地控制资源的生命周期，确保只加载一次并持续使用，而不是反复加载和卸载。这有助于避免内存泄漏和过度的内存分配。
- **共享资源**：在游戏中，很多资源如背景图片、角色贴图等可能会在多个地方使用。将图片数组放在全局范围或作为长期存活的对象的一部分，可以方便这些资源在游戏的不同部分之间共享。

##### 代码的可维护性与可读性

- **减少代码重复**：如果每次在函数中加载图片，将导致大量重复的加载代码，使得代码膨胀，难以维护。将这些资源的加载放在一个集中的位置，可以使代码更加清晰，更易于管理。
- **逻辑清晰**：将游戏资源的加载与游戏逻辑分离，有助于保持代码的组织性和逻辑清晰。这样，开发者可以更专注于游戏逻辑的编写，而不是不断处理资源加载。

##### 实践示例

  在游戏开发的实践中，常常在游戏启动时或场景加载时，预先加载并初始化所有必要的资源（包括图片数组），然后在游戏循环中使用这些预加载的资源。这种方式有助于提高游戏性能，减少内存使用，同时也使代码结构更加合理。

  总的来说，将图片数组放在函数外部是一种优化游戏性能、资源管理和代码结构的有效方式。这种做法符合游戏开发中资源优化和代码组织的最佳实践。

------



### 动画帧索引

```
const int PLAYER_ANIM_NUM = 6;
```

定义了一个常量 `PLAYER_ANIM_NUM`，它表示动画序列中的帧数。在这里，动画序列中有6帧。

```
int idx_current_anim = 0;
```

定义了一个变量 `idx_current_anim`，它用于追踪当前的动画帧索引。动画从索引0开始，这通常对应于动画序列的第一帧。

```
static int counter = 0;
```

定义了一个静态变量 `counter`，并初始化为0。由于它是静态的，它的值在函数调用之间将保持不变，这意味着每次函数执行时，`counter` 的值都将保持上一次函数调用结束时的值。

```
if (++counter % 5 == 0) 
```

这行代码首先将 `counter` 的值递增1，然后检查新的 `counter` 值是否是5的倍数。如果是5的倍数，`if` 语句内的代码块将被执行。

```
idx_current_anim++;
```

如果 `counter` 的值是5的倍数，当前动画帧索引 `idx_current_anim` 将递增1。这意味着每5次计数，动画帧将前进到下一帧。

```
idx_current_anim %= PLAYER_ANIM_NUM;
```

这行代码通过取模运算（`%`）确保 `idx_current_anim` 的值始终在0到 `PLAYER_ANIM_NUM - 1`（在这个例子中是5）之间。这样的话，当 `idx_current_anim` 达到6时，它将被重置为0，动画循环回到第一帧。这样可以确保不会访问不存在的动画帧索引，实现动画的循环播放。

这些代码的作用是控制动画帧索引的递增。动画帧索引每次只有在 `counter` 计数达到5的倍数时才递增，从而减慢动画帧的切换速度。当索引超出动画帧数时，它会循环回到第一帧，使动画连续播放。

------



### inline

`  inline` 关键字是对编译器的一种请求，告诉编译器在每次调用函数的地方尽可能地将函数的代码直接插入，而不是进行函数调用的开销。这通常用于优化小型、高频调用的函数。

  当编译器处理一个 `inline` 函数时，它会尝试将函数的代码直接嵌入到每一个调用点，从而减少函数调用的开销，这包括了调用和返回时压栈、出栈的操作。

使用 `inline` 函数有几个好处：

1. **减少函数调用开销**：由于没有涉及到实际的调用机制（即没有压栈、跳转等操作），因此省去了一些处理时间。
2. **避免函数调用的额外开销**：传递参数和返回结果通常需要通过寄存器或栈来完成，而 `inline` 函数可以直接使用原地的变量。
3. **提高缓存命中率**：由于函数代码是直接插入的，因此可能提高CPU缓存命中率，使程序运行更快。

然而，这也有潜在缺点：

1. **增加代码体积**：如果一个 `inline` 函数在多处被调用，每个调用点都会插入函数的代码副本，这可能导致可执行文件大小增加。
2. **可能降低性能**：如果 `inline` 函数的体积很大，编译器插入函数代码可能会使CPU缓存无法有效利用，从而降低程序运行效率。
3. **编译器可能忽略 `inline` 请求**：编译器可能会因为各种原因（如函数体太大或存在复杂的控制流）决定不将函数实际内联。

在你提供的函数 `putimage_alpha` 中，`inline` 关键字的使用是为了请求编译器在每次调用该函数时尽量将其内联，这是因为这个函数可能非常短小，且被频繁调用（每次绘制一个带透明度的图像时）。不过，是否真的内联由编译器决定，`inline` 仅是一个请求而已。



------

### MSDN

  在MSDN（Microsoft Developer Network）中查询`AlphaBlend`函数的使用方法是一个很好的学习途径，因为MSDN提供了详尽的Windows API文档，包括函数的定义、参数描述、返回值、错误处理和示例代码。

1. **打开Web浏览器**：首先，在你的计算机上启动任何一个网络浏览器。
2. **访问MSDN文档**：你可以直接访问[Microsoft Docs](https://docs.microsoft.com/)，这是Microsoft的官方技术文档网站，已经取代了早期的MSDN文档库。Microsoft Docs提供了广泛的文档，包括API参考、教程和指南。
3. **使用搜索功能**：在Microsoft Docs网站的顶部，你会找到一个搜索栏。在搜索栏中键入`AlphaBlend`，然后按Enter键进行搜索。
4. **查看搜索结果**：搜索结果将会显示与`AlphaBlend`相关的文档链接。通常，你会看到一个或多个结果指向API的详细描述和使用方法。
5. **选择正确的文档**：点击最相关的链接，通常是直接指向`AlphaBlend`函数的文档页面。确保你查看的是Windows API的相关页面，因为同一个函数名可能在不同的编程环境中有不同的含义。
6. **阅读文档**：在`AlphaBlend`的文档页面里，你将会找到包括以下内容的详细信息：
	- 函数的原型。
	- 参数的详细解释。
	- 返回值说明。
	- 必要条件和限制。
	- 示例代码段。
	- 相关函数和资源的链接。
7. **查看示例代码**：MSDN文档通常会提供示例代码来演示如何在实际应用程序中使用该函数。研究这些示例可以帮助你更好地理解函数的用法。
8. **使用文档中的资源**：除了函数的具体用法，MSDN文档还可能提供有关概念解释、编程指南和相关API的链接，这些资源对于深入理解`AlphaBlend`函数及其在大型项目中的应用也很有帮助。

通过以上步骤，你可以有效地利用MSDN来查询`AlphaBlend`函数的使用方法，进而加深对Windows API编程的理解。阅读和实践是学习编程的关键步骤，尝试根据文档中的信息编写和运行你自己的代码示例，这将是一个很好的学习过程。

------



### Alpha混合

  先前问过了老师是否可以通过新建透明画布然后扣除背景的以放置带有透明度信息的图片的方式来取代老师上课讲的用遮罩以实现图片背景透明的效果，在网上查找一番后又翻阅了msdn，使用了Windows GDI的`AlphaBlend`函数



Alpha混合（Alpha Blending）是一种在计算机图形中将两个图像或颜色混合在一起的技术，通常用于创建透明效果。Alpha混合使用了每个图像或颜色的Alpha通道来确定如何混合。Alpha通道是一个表示透明度级别的值，通常用0到255之间的整数表示，其中0表示完全透明，255表示完全不透明。

**混合模式概述**：

在Alpha混合中，每个像素颜色的最终结果是通过结合源像素（要绘制的像素）和目标像素（已经在屏幕上的像素，或者叫背景像素）而生成的。混合的基本公式如下：

```
result = source * alpha + destination * (1 - alpha)
```

这里的 `alpha` 是源像素的Alpha值（范围从0到1，0代表完全透明，1代表完全不透明）。当 `alpha` 是0时，结果就是目标颜色；当 `alpha` 是1时，结果就是源颜色。中间的值会产生源颜色和目标颜色的混合，源颜色的Alpha值越高，它对最终结果的贡献就越大。

**混合模式的种类**：

- **正常（Normal）**：源颜色覆盖目标颜色，根据源的Alpha值进行混合。
- **叠加（Overlay）**：结合源颜色和目标颜色的亮度，产生高亮或阴影效果而不改变颜色。
- **屏幕（Screen）**：让源和目标颜色更亮，通常用于创建光照效果。
- **乘法（Multiply）**：颜色相乘，结果较暗，常用于创建阴影和深度效果。
- **加法（Add）**：颜色相加，结果较亮，可以用于发光效果。

**在图形API中的应用**：

不同的图形API如OpenGL、DirectX或基于Windows的GDI提供了不同级别的支持和不同的方法来实现Alpha混合。例如，在使用`AlphaBlend`函数时，Alpha混合通常是通过BLENDFUNCTION结构来控制的，它定义了Alpha的操作以及是否使用像素的Alpha值或使用一个全局的Alpha值。

在更高级的图形引擎或框架中，如Unity或Unreal Engine，Alpha混合可以通过着色器（Shaders）和材料（Materials）系统来控制，允许开发者创造各种复杂的透明和混合效果。

Alpha混合是一个强大的工具，可以用来创建层次丰富、视觉上引人入胜的图形效果，特别是在实现透明、半透明对象、软边缘、光晕和其他复杂光照效果时。



